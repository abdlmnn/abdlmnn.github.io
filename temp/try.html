<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js Globe - Focused View</title>

  <!-- =================== CSS =================== -->
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: Arial, sans-serif;
    }

    /* Set a white background */
    #globe-container {
      width: 100vw;
      height: 100vh;
      background-color: #ffffff;
    }

    /* Loading indicator */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #333;
      font-size: 18px;
      z-index: 1000;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgba(255, 255, 255, 0.9);
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border-left-color: #00ffff;
      animation: spin 1s ease infinite;
      margin-bottom: 10px;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Tooltip styles */
    .tooltip {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.85);
      color: white;
      padding: 10px;
      border-radius: 8px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: 1000;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      max-width: 200px;
    }

    .tooltip.show {
      opacity: 1;
    }

    .tooltip h3 {
      margin: 0 0 8px 0;
      font-size: 16px;
      color: #00ffff;
    }

    .tooltip img {
      width: 100%;
      height: auto;
      border-radius: 4px;
      margin-bottom: 5px;
    }

    .tooltip p {
      margin: 0;
      font-size: 12px;
      line-height: 1.4;
    }
  </style>

  <!-- =================== THREE.JS LIBRARIES =================== -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
  <div id="globe-container">
    <div id="loading">
      <div class="spinner"></div>
    </div>
  </div>

  <div id="tooltip" class="tooltip">
    <h3 id="tooltip-title"></h3>
    <img id="tooltip-image" src="" alt="" />
    <p id="tooltip-description"></p>
  </div>

  <script>
    let airplane;
    let routeCurve;
    let airplaneProgress = 0;
    let markers = [];
    let raycaster;
    let mouse;
    let tooltip;
    let loadingIndicator;
    let globe;
    let scene;
    let camera;
    let renderer;
    let controls;

    // --- HELPER FUNCTION TO CONVERT LAT/LON TO 3D COORDINATES ---
    function latLonToVector3(lat, lon, radius) {
      const phi = (90 - lat) * (Math.PI / 180);
      const theta = (lon + 180) * (Math.PI / 180);
      const x = -(radius * Math.sin(phi) * Math.cos(theta));
      const z = radius * Math.sin(phi) * Math.sin(theta);
      const y = radius * Math.cos(phi);
      return new THREE.Vector3(x, y, z);
    }

    // --- HELPER FUNCTION TO CREATE A CURVED PATH AND VISUAL LINE ---
    function createCurve(startLat, startLon, endLat, endLon, globeRadius) {
      const curvePoints = 100;
      const points = [];
      for (let i = 0; i <= curvePoints; i++) {
        const t = i / curvePoints;
        const lat = startLat + (endLat - startLat) * t;
        const lon = startLon + (endLon - startLon) * t;
        const point = latLonToVector3(lat, lon, globeRadius + 0.01);
        points.push(point);
      }
      const curve = new THREE.CatmullRomCurve3(points);
      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      // Use LineDashedMaterial for dashed line
      const material = new THREE.LineDashedMaterial({
        color: 0x00ffff, // Cyan color
        linewidth: 2,
        dashSize: 0.05, // Length of dashes
        gapSize: 0.03, // Length of gaps
      });
      const line = new THREE.Line(geometry, material);
      // Compute line distances for dashes to work
      line.computeLineDistances();
      return { curve, line };
    }

    // --- FUNCTION TO CREATE A REALISTIC AIRPLANE ---
    function createRealisticAirplane() {
      const airplaneGroup = new THREE.Group();

      // Create materials
      const bodyMaterial = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        metalness: 0.7,
        roughness: 0.3,
      });

      const wingMaterial = new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 0.6,
        roughness: 0.4,
      });

      // Fuselage (main body)
      const fuselageGeometry = new THREE.CylinderGeometry(
        0.008,
        0.015,
        0.12,
        12,
      );
      const fuselage = new THREE.Mesh(fuselageGeometry, bodyMaterial);
      fuselage.rotation.z = Math.PI / 2;
      airplaneGroup.add(fuselage);

      // Nose cone
      const noseGeometry = new THREE.ConeGeometry(0.008, 0.03, 8);
      const nose = new THREE.Mesh(noseGeometry, bodyMaterial);
      nose.rotation.z = -Math.PI / 2;
      nose.position.x = 0.075;
      airplaneGroup.add(nose);

      // Main wings
      const mainWingGeometry = new THREE.BoxGeometry(0.001, 0.12, 0.015);
      const mainWings = new THREE.Mesh(mainWingGeometry, wingMaterial);
      mainWings.position.x = 0.02;
      airplaneGroup.add(mainWings);

      // Tail wings (horizontal)
      const tailWingGeometry = new THREE.BoxGeometry(0.001, 0.04, 0.01);
      const tailWings = new THREE.Mesh(tailWingGeometry, wingMaterial);
      tailWings.position.x = -0.05;
      airplaneGroup.add(tailWings);

      // Vertical tail fin
      const tailFinGeometry = new THREE.BoxGeometry(0.001, 0.01, 0.03);
      const tailFin = new THREE.Mesh(tailFinGeometry, wingMaterial);
      tailFin.position.x = -0.05;
      tailFin.rotation.z = Math.PI / 2;
      airplaneGroup.add(tailFin);

      // Engines
      const engineGeometry = new THREE.CylinderGeometry(
        0.006,
        0.006,
        0.03,
        8,
      );
      const engine1 = new THREE.Mesh(engineGeometry, bodyMaterial);
      engine1.rotation.z = Math.PI / 2;
      engine1.position.set(0.02, 0.04, 0);
      airplaneGroup.add(engine1);

      const engine2 = new THREE.Mesh(engineGeometry, bodyMaterial);
      engine2.rotation.z = Math.PI / 2;
      engine2.position.set(0.02, -0.04, 0);
      airplaneGroup.add(engine2);

      // Windows
      const windowMaterial = new THREE.MeshBasicMaterial({ color: 0x4444ff });
      for (let i = 0; i < 5; i++) {
        const windowGeometry = new THREE.SphereGeometry(0.002, 6, 6);
        const window = new THREE.Mesh(windowGeometry, windowMaterial);
        window.position.x = 0.03 + i * 0.01;
        window.position.z = 0.008;
        airplaneGroup.add(window);
      }

      return airplaneGroup;
    }

    // --- FUNCTION TO ADD MARKERS AND ROUTE AFTER TEXTURE LOADS ---
    function addMarkersAndRoute() {
      // Define locations
      const locations = [
        {
          name: "Philippines",
          lat: 14.6,
          lon: 121.0,
          image: "https://picsum.photos/seed/philippines/200/120.jpg",
          description: "Beautiful archipelago in Southeast Asia",
        },
        {
          name: "Saudi Arabia",
          lat: 24.7,
          lon: 46.7,
          image: "https://picsum.photos/seed/saudiarabia/200/120.jpg",
          description: "Desert kingdom in the Middle East",
        },
      ];

      // Add markers
      locations.forEach((location) => {
        const markerPos = latLonToVector3(location.lat, location.lon, 1.02);
        const markerGeometry = new THREE.SphereGeometry(0.02, 16, 16);
        const markerMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
        });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        marker.position.copy(markerPos);
        marker.userData = location; // Store location data in marker
        globe.add(marker);
        markers.push(marker);
      });

      // Add the route path
      const startPoint = locations[1];
      const endPoint = locations[0];
      const routeData = createCurve(
        startPoint.lat,
        startPoint.lon,
        endPoint.lat,
        endPoint.lon,
        1,
      );
      routeCurve = routeData.curve;
      globe.add(routeData.line);

      // Create and add the airplane
      airplane = createRealisticAirplane();
      const startPosition = routeCurve.getPoint(0);
      airplane.position.copy(startPosition);
      airplane.scale.set(0.4, 0.4, 0.4);
      globe.add(airplane);
    }

    // --- INITIALIZATION FUNCTION ---
    function init() {
      // --- 1. SCENE SETUP ---
      scene = new THREE.Scene();
      // Set scene background to white
      scene.background = new THREE.Color(0xffffff);

      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );

      // --- POSITION CAMERA TO FOCUS ON THE PHILIPPINES BY DEFAULT ---
      // Focus on the Philippines initially
      const philippinesLat = 14.6;
      const philippinesLon = 121.0;
      const focalPoint = latLonToVector3(philippinesLat, philippinesLon, 1); // Get the 3D position on the globe

      // Position the camera relative to that focal point
      const cameraDistance = 2.5; // Brought camera closer for better visibility
      camera.position.copy(focalPoint).multiplyScalar(cameraDistance);
      camera.lookAt(0, 0, 0); // Point the camera towards the center of the globe

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document
        .getElementById("globe-container")
        .appendChild(renderer.domElement);

      // --- 2. CREATE THE GLOBE ---
      const globeGeometry = new THREE.SphereGeometry(1, 64, 64);

      // Create material with white color initially
      const globeMaterial = new THREE.MeshStandardMaterial({
        color: 0xffffff, // Set initial color to white
        metalness: 0.1,
        roughness: 0.7,
      });

      globe = new THREE.Mesh(globeGeometry, globeMaterial);
      scene.add(globe);

      // --- 3. LIGHTING ---
      // Increased ambient light for overall brightness
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
      scene.add(ambientLight);

      // Main directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(5, 5, 5);
      scene.add(directionalLight);

      // Additional directional light to illuminate the Saudi Arabia and Philippines areas
      const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
      directionalLight2.position.set(-5, 3, -5);
      scene.add(directionalLight2);

      // Third light from below to reduce shadows
      const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.3);
      directionalLight3.position.set(0, -5, 0);
      scene.add(directionalLight3);

      // --- 4. MOUSE CONTROLS ---
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 1.5;
      controls.maxDistance = 10;

      // --- 5. SETUP RAYCASTER FOR HOVER DETECTION ---
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      tooltip = document.getElementById("tooltip");

      // --- MOUSE MOVE EVENT FOR HOVER ---
      function onMouseMove(event) {
        // Calculate mouse position in normalized device coordinates
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        // Update the raycaster with the camera and mouse position
        raycaster.setFromCamera(mouse, camera);

        // Calculate objects intersecting the raycaster
        const intersects = raycaster.intersectObjects(markers);

        if (intersects.length > 0) {
          // Show tooltip
          const marker = intersects[0].object;
          const location = marker.userData;

          document.getElementById("tooltip-title").textContent =
            location.name;
          document.getElementById("tooltip-image").src = location.image;
          document.getElementById("tooltip-description").textContent =
            location.description;

          tooltip.style.left = event.clientX + 10 + "px";
          tooltip.style.top = event.clientY - 10 + "px";
          tooltip.classList.add("show");

          // Change marker color on hover
          marker.material.color.set(0xffff00);
        } else {
          // Hide tooltip
          tooltip.classList.remove("show");

          // Reset marker colors
          markers.forEach((marker) => {
            marker.material.color.set(0xff0000);
          });
        }
      }

      window.addEventListener("mousemove", onMouseMove, false);

      // --- 6. LOAD TEXTURE AND ADD ELEMENTS ---
      const textureLoader = new THREE.TextureLoader();
      textureLoader.load(
        "https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg",
        // onLoad
        function (texture) {
          // Apply the texture once loaded
          globe.material.map = texture;
          globe.material.needsUpdate = true;

          // Now add markers and route after texture is loaded
          addMarkersAndRoute();

          // Hide loading indicator
          if (loadingIndicator) {
            loadingIndicator.style.display = "none";
          }
        },
        // onProgress
        function (xhr) {
          const percentComplete = Math.round((xhr.loaded / xhr.total) * 100);
          if (loadingIndicator) {
            loadingIndicator.querySelector("p").textContent =
              `Loading Globe... ${percentComplete}%`;
          }
        },
        // onError
        function (error) {
          console.error("An error happened during texture loading:", error);
          // Still add markers and route even if texture fails
          addMarkersAndRoute();

          if (loadingIndicator) {
            loadingIndicator.innerHTML =
              "<p>Failed to load Earth texture</p>";
            // Hide error message after 3 seconds
            setTimeout(() => {
              loadingIndicator.style.display = "none";
            }, 3000);
          }
        },
      );

      // --- 7. ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);
        // Globe rotation
        if (globe) {
          globe.rotation.y += 0.0005;
        }

        if (airplane && routeCurve) {
          // Airplane movement
          airplaneProgress += 0.002;
          if (airplaneProgress > 1) {
            airplaneProgress = 0;
          }

          const currentPosition = routeCurve.getPoint(airplaneProgress);
          const lookAtPosition = routeCurve.getPoint(
            Math.min(1, airplaneProgress + 0.01),
          );

          airplane.position.copy(currentPosition);

          // Calculate the direction vector
          const direction = new THREE.Vector3()
            .subVectors(lookAtPosition, currentPosition)
            .normalize();

          // Create a temporary object to handle rotation
          const tempObject = new THREE.Object3D();
          tempObject.position.copy(currentPosition);
          tempObject.lookAt(lookAtPosition);

          // Apply the rotation to the airplane
          airplane.rotation.copy(tempObject.rotation);

          // Adjust the airplane to fly level (correct upside down issue)
          airplane.rotateX(Math.PI / 2);
        }

        if (controls) {
          controls.update();
        }

        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
      }

      // --- 8. HANDLE WINDOW RESIZING ---
      window.addEventListener("resize", () => {
        if (camera) {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
        }
        if (renderer) {
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });

      // Start the animation
      animate();
    }

    // Initialize when DOM is loaded
    document.addEventListener("DOMContentLoaded", function () {
      loadingIndicator = document.getElementById("loading");
      init();
    });
  </script>
</body>

</html>
